{
  "version": 3,
  "sources": ["../../@hookform/resolvers/zod/src/zod.ts"],
  "sourcesContent": ["import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport {\n  FieldError,\n  FieldErrors,\n  FieldValues,\n  Resolver,\n  ResolverError,\n  ResolverSuccess,\n  appendErrors,\n} from 'react-hook-form';\nimport * as z3 from 'zod/v3';\nimport * as z4 from 'zod/v4/core';\n\nconst isZod3Error = (error: any): error is z3.ZodError => {\n  return Array.isArray(error?.issues);\n};\nconst isZod3Schema = (schema: any): schema is z3.ZodSchema => {\n  return (\n    '_def' in schema &&\n    typeof schema._def === 'object' &&\n    'typeName' in schema._def\n  );\n};\nconst isZod4Error = (error: any): error is z4.$ZodError => {\n  // instanceof is safe in Zod 4 (uses Symbol.hasInstance)\n  return error instanceof z4.$ZodError;\n};\nconst isZod4Schema = (schema: any): schema is z4.$ZodType => {\n  return '_zod' in schema && typeof schema._zod === 'object';\n};\n\nfunction parseZod3Issues(\n  zodErrors: z3.ZodIssue[],\n  validateAllFieldCriteria: boolean,\n) {\n  const errors: Record<string, FieldError> = {};\n  for (; zodErrors.length; ) {\n    const error = zodErrors[0];\n    const { code, message, path } = error;\n    const _path = path.join('.');\n\n    if (!errors[_path]) {\n      if ('unionErrors' in error) {\n        const unionError = error.unionErrors[0].errors[0];\n\n        errors[_path] = {\n          message: unionError.message,\n          type: unionError.code,\n        };\n      } else {\n        errors[_path] = { message, type: code };\n      }\n    }\n\n    if ('unionErrors' in error) {\n      error.unionErrors.forEach((unionError) =>\n        unionError.errors.forEach((e) => zodErrors.push(e)),\n      );\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[error.code];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        code,\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    zodErrors.shift();\n  }\n\n  return errors;\n}\n\nfunction parseZod4Issues(\n  zodErrors: z4.$ZodIssue[],\n  validateAllFieldCriteria: boolean,\n) {\n  const errors: Record<string, FieldError> = {};\n  // const _zodErrors = zodErrors as z4.$ZodISsue; //\n  for (; zodErrors.length; ) {\n    const error = zodErrors[0];\n    const { code, message, path } = error;\n    const _path = path.join('.');\n\n    if (!errors[_path]) {\n      if (error.code === 'invalid_union' && error.errors.length > 0) {\n        const unionError = error.errors[0][0];\n\n        errors[_path] = {\n          message: unionError.message,\n          type: unionError.code,\n        };\n      } else {\n        errors[_path] = { message, type: code };\n      }\n    }\n\n    if (error.code === 'invalid_union') {\n      error.errors.forEach((unionError) =>\n        unionError.forEach((e) => zodErrors.push(e)),\n      );\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[error.code];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        code,\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    zodErrors.shift();\n  }\n\n  return errors;\n}\n\ntype RawResolverOptions = {\n  mode?: 'async' | 'sync';\n  raw: true;\n};\ntype NonRawResolverOptions = {\n  mode?: 'async' | 'sync';\n  raw?: false;\n};\n\n// minimal interfaces to avoid asssignability issues between versions\ninterface Zod3Type<O = unknown, I = unknown> {\n  _output: O;\n  _input: I;\n  _def: {\n    typeName: string;\n  };\n}\n\n// some type magic to make versions pre-3.25.0 still work\ntype IsUnresolved<T> = PropertyKey extends keyof T ? true : false;\ntype UnresolvedFallback<T, Fallback> = IsUnresolved<typeof z3> extends true\n  ? Fallback\n  : T;\ntype FallbackIssue = {\n  code: string;\n  message: string;\n  path: (string | number)[];\n};\ntype Zod3ParseParams = UnresolvedFallback<\n  z3.ParseParams,\n  // fallback if user is on <3.25.0\n  {\n    path?: (string | number)[];\n    errorMap?: (\n      iss: FallbackIssue,\n      ctx: {\n        defaultError: string;\n        data: any;\n      },\n    ) => { message: string };\n    async?: boolean;\n  }\n>;\ntype Zod4ParseParams = UnresolvedFallback<\n  z4.ParseContext<z4.$ZodIssue>,\n  // fallback if user is on <3.25.0\n  {\n    readonly error?: (\n      iss: FallbackIssue,\n    ) => null | undefined | string | { message: string };\n    readonly reportInput?: boolean;\n    readonly jitless?: boolean;\n  }\n>;\n\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: Zod3Type<Output, Input>,\n  schemaOptions?: Zod3ParseParams,\n  resolverOptions?: NonRawResolverOptions,\n): Resolver<Input, Context, Output>;\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: Zod3Type<Output, Input>,\n  schemaOptions: Zod3ParseParams | undefined,\n  resolverOptions: RawResolverOptions,\n): Resolver<Input, Context, Input>;\n// the Zod 4 overloads need to be generic for complicated reasons\nexport function zodResolver<\n  Input extends FieldValues,\n  Context,\n  Output,\n  T extends z4.$ZodType<Output, Input> = z4.$ZodType<Output, Input>,\n>(\n  schema: T,\n  schemaOptions?: Zod4ParseParams, // already partial\n  resolverOptions?: NonRawResolverOptions,\n): Resolver<z4.input<T>, Context, z4.output<T>>;\nexport function zodResolver<\n  Input extends FieldValues,\n  Context,\n  Output,\n  T extends z4.$ZodType<Output, Input> = z4.$ZodType<Output, Input>,\n>(\n  schema: z4.$ZodType<Output, Input>,\n  schemaOptions: Zod4ParseParams | undefined, // already partial\n  resolverOptions: RawResolverOptions,\n): Resolver<z4.input<T>, Context, z4.output<T>>;\n/**\n * Creates a resolver function for react-hook-form that validates form data using a Zod schema\n * @param {z3.ZodSchema<Input>} schema - The Zod schema used to validate the form data\n * @param {Partial<z3.ParseParams>} [schemaOptions] - Optional configuration options for Zod parsing\n * @param {Object} [resolverOptions] - Optional resolver-specific configuration\n * @param {('async'|'sync')} [resolverOptions.mode='async'] - Validation mode. Use 'sync' for synchronous validation\n * @param {boolean} [resolverOptions.raw=false] - If true, returns the raw form values instead of the parsed data\n * @returns {Resolver<z3.output<typeof schema>>} A resolver function compatible with react-hook-form\n * @throws {Error} Throws if validation fails with a non-Zod error\n * @example\n * const schema = z3.object({\n *   name: z3.string().min(2),\n *   age: z3.number().min(18)\n * });\n *\n * useForm({\n *   resolver: zodResolver(schema)\n * });\n */\nexport function zodResolver<Input extends FieldValues, Context, Output>(\n  schema: object,\n  schemaOptions?: object,\n  resolverOptions: {\n    mode?: 'async' | 'sync';\n    raw?: boolean;\n  } = {},\n): Resolver<Input, Context, Output | Input> {\n  if (isZod3Schema(schema)) {\n    return async (values: Input, _, options) => {\n      try {\n        const data = await schema[\n          resolverOptions.mode === 'sync' ? 'parse' : 'parseAsync'\n        ](values, schemaOptions);\n\n        options.shouldUseNativeValidation &&\n          validateFieldsNatively({}, options);\n\n        return {\n          errors: {} as FieldErrors,\n          values: resolverOptions.raw ? Object.assign({}, values) : data,\n        } satisfies ResolverSuccess<Output | Input>;\n      } catch (error) {\n        if (isZod3Error(error)) {\n          return {\n            values: {},\n            errors: toNestErrors(\n              parseZod3Issues(\n                error.errors,\n                !options.shouldUseNativeValidation &&\n                  options.criteriaMode === 'all',\n              ),\n              options,\n            ),\n          } satisfies ResolverError<Input>;\n        }\n\n        throw error;\n      }\n    };\n  }\n\n  if (isZod4Schema(schema)) {\n    return async (values: Input, _, options) => {\n      try {\n        const parseFn =\n          resolverOptions.mode === 'sync' ? z4.parse : z4.parseAsync;\n        const data: any = await parseFn(schema, values, schemaOptions);\n\n        options.shouldUseNativeValidation &&\n          validateFieldsNatively({}, options);\n\n        return {\n          errors: {} as FieldErrors,\n          values: resolverOptions.raw ? Object.assign({}, values) : data,\n        } satisfies ResolverSuccess<Output | Input>;\n      } catch (error) {\n        if (isZod4Error(error)) {\n          return {\n            values: {},\n            errors: toNestErrors(\n              parseZod4Issues(\n                error.issues,\n                !options.shouldUseNativeValidation &&\n                  options.criteriaMode === 'all',\n              ),\n              options,\n            ),\n          } satisfies ResolverError<Input>;\n        }\n\n        throw error;\n      }\n    };\n  }\n\n  throw new Error('Invalid input: not a Zod schema');\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AA+BA,SAASA,GACPC,GACAC,GAAAA;AAGA,WADMC,IAAqC,CAAE,GACtCF,EAAUG,UAAU;AACzB,QAAMC,KAAQJ,EAAU,CAAA,GAChBK,KAAwBD,GAAxBC,MAAMC,KAAkBF,GAAlBE,SACRC,KAD0BH,GAATI,KACJC,KAAK,GAAA;AAExB,QAAA,CAAKP,EAAOK,EAAAA,EACV,KAAI,iBAAiBH,IAAO;AAC1B,UAAMM,IAAaN,GAAMO,YAAY,CAAA,EAAGT,OAAO,CAAA;AAE/CA,QAAOK,EAAAA,IAAS,EACdD,SAASI,EAAWJ,SACpBM,MAAMF,EAAWL,KAAAA;IAErB,MACEH,GAAOK,EAAAA,IAAS,EAAED,SAAAA,IAASM,MAAMP,GAAAA;AAUrC,QANI,iBAAiBD,MACnBA,GAAMO,YAAYE,QAAQ,SAACH,IAAAA;AACzB,aAAAA,GAAWR,OAAOW,QAAQ,SAACC,IAAAA;AAAM,eAAAd,EAAUe,KAAKD,EAAAA;MAAE,CAAA;IAAC,CAAA,GAInDb,GAA0B;AAC5B,UAAMe,IAAQd,EAAOK,EAAAA,EAAOS,OACtBC,IAAWD,KAASA,EAAMZ,GAAMC,IAAAA;AAEtCH,QAAOK,EAAAA,IAASW,aACdX,IACAN,GACAC,GACAG,IACAY,IACK,CAAA,EAAgBE,OAAOF,GAAsBb,GAAME,OAAAA,IACpDF,GAAME,OAAAA;IAEd;AAEAN,MAAUoB,MAAAA;EACZ;AAEA,SAAOlB;AACT;AAEA,SAASmB,EACPrB,GACAC,GAAAA;AAIA,WAFMC,IAAqC,CAAA,GAEpCF,EAAUG,UAAU;AACzB,QAAMC,KAAQJ,EAAU,CAAA,GAChBK,KAAwBD,GAAxBC,MAAMC,KAAkBF,GAAlBE,SACRC,KAD0BH,GAATI,KACJC,KAAK,GAAA;AAExB,QAAA,CAAKP,EAAOK,EAAAA,EACV,KAAmB,oBAAfH,GAAMC,QAA4BD,GAAMF,OAAOC,SAAS,GAAG;AAC7D,UAAMO,IAAaN,GAAMF,OAAO,CAAA,EAAG,CAAA;AAEnCA,QAAOK,EAAAA,IAAS,EACdD,SAASI,EAAWJ,SACpBM,MAAMF,EAAWL,KAAAA;IAErB,MACEH,GAAOK,EAAAA,IAAS,EAAED,SAAAA,IAASM,MAAMP,GAAAA;AAUrC,QANmB,oBAAfD,GAAMC,QACRD,GAAMF,OAAOW,QAAQ,SAACH,IAAAA;AACpB,aAAAA,GAAWG,QAAQ,SAACC,IAAAA;AAAM,eAAAd,EAAUe,KAAKD,EAAAA;MAAE,CAAA;IAAC,CAAA,GAI5Cb,GAA0B;AAC5B,UAAMe,IAAQd,EAAOK,EAAAA,EAAOS,OACtBC,IAAWD,KAASA,EAAMZ,GAAMC,IAAAA;AAEtCH,QAAOK,EAAAA,IAASW,aACdX,IACAN,GACAC,GACAG,IACAY,IACK,CAAA,EAAgBE,OAAOF,GAAsBb,GAAME,OAAAA,IACpDF,GAAME,OAAAA;IAEd;AAEAN,MAAUoB,MAAAA;EACZ;AAEA,SAAOlB;AACT;AA2GgB,SAAAoB,EACdC,IACAC,IACAC,GAAAA;AAKA,MAAA,WALAA,MAAAA,IAGI,CAAA,KAnOe,SAACF,GAAAA;AACpB,WACE,UAAUA,KACa,YAAA,OAAhBA,EAAOG,QACd,cAAcH,EAAOG;EAEzB,GA+NmBH,EAAAA,EACf,QAAcI,SAAAA,GAAeC,IAAGC,GAAAA;AAAW,QAAA;AAAA,aAAAC,QAAAC,QAAAC,EAAA,WAAA;AACrCF,eAAAA,QAAAC,QACiBR,GACQ,WAAzBE,EAAgBQ,OAAkB,UAAU,YAAA,EAC5CN,GAAQH,EAAAA,CAAAA,EAAcU,KAAA,SAFlBC,GAAAA;AAON,iBAHAN,EAAQO,6BACNC,EAAuB,CAAA,GAAIR,CAAAA,GAEtB,EACL3B,QAAQ,CAAiB,GACzByB,QAAQF,EAAgBa,MAAMC,OAAOC,OAAO,CAAA,GAAIb,CAAAA,IAAUQ,EAAAA;QAChB,CAAA;MAC9C,GAAS/B,SAAAA,GAAAA;AACP,aAvPY,SAACA,IAAAA;AACnB,iBAAOqC,MAAMC,QAAAA,QAAQtC,KAAAA,SAAAA,GAAOuC,MAAAA;QAC9B,GAqPwBvC,CAAAA,EACd,QAAO,EACLuB,QAAQ,CAAA,GACRzB,QAAQ0C,EACN7C,GACEK,EAAMF,QAAAA,CACL2B,EAAQO,6BACkB,UAAzBP,EAAQgB,YAAAA,GAEZhB,CAAAA,EAAAA;AAKN,cAAMzB;MACR,CAAA,CAAA;IACF,SAACU,GAAAA;AAAAgB,aAAAA,QAAAgB,OAAAhC,CAAAA;IACH;EAAA;AAEA,OA5PmB,SAACS,GAAAA;AACpB,WAAO,UAAUA,KAAiC,YAAA,OAAhBA,EAAOwB;EAC3C,GA0PmBxB,EAAAA,EACf,QAAA,SAAcI,IAAeC,GAAGC,GAAAA;AAAW,QAAA;AAAA,aAAAC,QAAAC,QAAAC,EAAA,WAAA;AAGsB,eAAAF,QAAAC,SAAlC,WAAzBN,EAAgBQ,OAAqBe,QAAWC,YAClB1B,IAAQI,IAAQH,EAAAA,CAAAA,EAAcU,KAAA,SAAxDC,GAAAA;AAKN,iBAHAN,EAAQO,6BACNC,EAAuB,CAAE,GAAER,CAAAA,GAEtB,EACL3B,QAAQ,CAAA,GACRyB,QAAQF,EAAgBa,MAAMC,OAAOC,OAAO,CAAE,GAAEb,EAAAA,IAAUQ,EAAAA;QAChB,CAAA;MAC9C,GAAS/B,SAAAA,GAAAA;AACP,aA/QY,SAACA,IAAAA;AAEnB,iBAAOA,cAAoB8C;QAC7B,GA4QwB9C,CAAAA,EACd,QAAO,EACLuB,QAAQ,CAAE,GACVzB,QAAQ0C,EACNvB,EACEjB,EAAMuC,QAAAA,CACLd,EAAQO,6BACkB,UAAzBP,EAAQgB,YAAAA,GAEZhB,CAAAA,EAAAA;AAKN,cAAMzB;MACR,CAAA,CAAA;IACF,SAACU,GAAAA;AAAAgB,aAAAA,QAAAgB,OAAAhC,CAAAA;IACH;EAAA;AAEA,QAAM,IAAIqC,MAAM,iCAAA;AAClB;",
  "names": ["parseZod3Issues", "zodErrors", "validateAllFieldCriteria", "errors", "length", "error", "code", "message", "_path", "path", "join", "unionError", "unionErrors", "type", "forEach", "e", "push", "types", "messages", "appendErrors", "concat", "shift", "parseZod4Issues", "zodResolver", "schema", "schemaOptions", "resolverOptions", "_def", "values", "_", "options", "Promise", "resolve", "_catch", "mode", "then", "data", "shouldUseNativeValidation", "validateFieldsNatively", "raw", "Object", "assign", "Array", "isArray", "issues", "toNestErrors", "criteriaMode", "reject", "_zod", "parse", "parseAsync", "$ZodError", "Error"]
}
