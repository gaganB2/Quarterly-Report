import {
  $ZodError,
  parse,
  parseAsync
} from "./chunk-KC22ZRHW.js";
import {
  o,
  s
} from "./chunk-K3BWY3FW.js";
import {
  appendErrors
} from "./chunk-ANTZT4DR.js";
import "./chunk-QJTFJ6OV.js";
import "./chunk-V4OQ3NZ2.js";

// node_modules/@hookform/resolvers/zod/dist/zod.mjs
function t(r, e) {
  try {
    var o2 = r();
  } catch (r2) {
    return e(r2);
  }
  return o2 && o2.then ? o2.then(void 0, e) : o2;
}
function s2(r, e) {
  for (var n = {}; r.length; ) {
    var t2 = r[0], s3 = t2.code, i2 = t2.message, a2 = t2.path.join(".");
    if (!n[a2]) if ("unionErrors" in t2) {
      var u = t2.unionErrors[0].errors[0];
      n[a2] = { message: u.message, type: u.code };
    } else n[a2] = { message: i2, type: s3 };
    if ("unionErrors" in t2 && t2.unionErrors.forEach(function(e2) {
      return e2.errors.forEach(function(e3) {
        return r.push(e3);
      });
    }), e) {
      var c = n[a2].types, f = c && c[t2.code];
      n[a2] = appendErrors(a2, e, n, s3, f ? [].concat(f, t2.message) : t2.message);
    }
    r.shift();
  }
  return n;
}
function i(r, e) {
  for (var n = {}; r.length; ) {
    var t2 = r[0], s3 = t2.code, i2 = t2.message, a2 = t2.path.join(".");
    if (!n[a2]) if ("invalid_union" === t2.code && t2.errors.length > 0) {
      var u = t2.errors[0][0];
      n[a2] = { message: u.message, type: u.code };
    } else n[a2] = { message: i2, type: s3 };
    if ("invalid_union" === t2.code && t2.errors.forEach(function(e2) {
      return e2.forEach(function(e3) {
        return r.push(e3);
      });
    }), e) {
      var c = n[a2].types, f = c && c[t2.code];
      n[a2] = appendErrors(a2, e, n, s3, f ? [].concat(f, t2.message) : t2.message);
    }
    r.shift();
  }
  return n;
}
function a(o2, a2, u) {
  if (void 0 === u && (u = {}), (function(r) {
    return "_def" in r && "object" == typeof r._def && "typeName" in r._def;
  })(o2)) return function(n, i2, c) {
    try {
      return Promise.resolve(t(function() {
        return Promise.resolve(o2["sync" === u.mode ? "parse" : "parseAsync"](n, a2)).then(function(e) {
          return c.shouldUseNativeValidation && o({}, c), { errors: {}, values: u.raw ? Object.assign({}, n) : e };
        });
      }, function(r) {
        if ((function(r2) {
          return Array.isArray(null == r2 ? void 0 : r2.issues);
        })(r)) return { values: {}, errors: s(s2(r.errors, !c.shouldUseNativeValidation && "all" === c.criteriaMode), c) };
        throw r;
      }));
    } catch (r) {
      return Promise.reject(r);
    }
  };
  if ((function(r) {
    return "_zod" in r && "object" == typeof r._zod;
  })(o2)) return function(s3, c, f) {
    try {
      return Promise.resolve(t(function() {
        return Promise.resolve(("sync" === u.mode ? parse : parseAsync)(o2, s3, a2)).then(function(e) {
          return f.shouldUseNativeValidation && o({}, f), { errors: {}, values: u.raw ? Object.assign({}, s3) : e };
        });
      }, function(r) {
        if ((function(r2) {
          return r2 instanceof $ZodError;
        })(r)) return { values: {}, errors: s(i(r.issues, !f.shouldUseNativeValidation && "all" === f.criteriaMode), f) };
        throw r;
      }));
    } catch (r) {
      return Promise.reject(r);
    }
  };
  throw new Error("Invalid input: not a Zod schema");
}
export {
  a as zodResolver
};
//# sourceMappingURL=@hookform_resolvers_zod.js.map
